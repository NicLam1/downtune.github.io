<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="style2.css"/>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://threejs.org/build/three.module.js",
                "three/addons/": "https://threejs.org/examples/jsm/"
            }
        }
    </script>
    <nav>
        <div class="nav-items"></div>
            <a href="#">Work</a>
            <a href="#">Archive</a>
        <div class="logo"></div>
            <a href="#">Tunnel Vision</a>
        <div class="nav-items"></div>
            <a href="#">Info</a>
            <a href="#">Contact</a>
    </nav>
    <footer>
        <p>ABC</p>
    </footer>

    <div class="container">
        <div class="overlay">
            <div class="slider"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { slides } from './data2.js'; // Make sure the path is correct


        console.log(THREE); // Testing if THREE is defined
        
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement); // Fixed this line

        const geometry = new THREE.PlaneGeometry(2, 2);
        const uniforms = {
            iTime: { value: 0 },
            iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            scrollOffset: { value: 0 },
        };

        const material = new THREE.ShaderMaterial({
            uniforms: uniforms, // Fixed spelling here
            vertexShader: document.getElementById("vertexShader").textContent, // Fixed spelling here
            fragmentShader: document.getElementById("fragmentShader").textContent,
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        let lastTime = 0;
        function animateTunnel(time) {
            const deltaTime = time - lastTime;
            lastTime = time;
            uniforms.iTime.value += deltaTime * 0.001;
            renderer.render(scene, camera);
            requestAnimationFrame(animateTunnel);
        }
        animateTunnel(0);

        window.addEventListener("resize", () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            uniforms.iResolution.value.set(width, height);
        }); // Fixed missing parentheses

        gsap.registerPlugin(ScrollTrigger);

        const totalSlides = 3; //set this to total number of slides
        const zStep = 2500;
        const initialZ = -22500;

        function generateSlides(){
            const slider = document.querySelector(".slider");
            slider.innerHTML = "";

            for (let i=1; i <= totalSlides; i++){
                
                const slide = document.createElement("div");
                slide.className = "slide";
                slide.id = `slide-${i}`;
                
                const slideImg = document.createElement("div");
                slideImg.className = "slide-img";

                const img = document.createElement("img");
                img.src = `src/img${i}.png`;
                img.alt = "";

                const slideCopy = document.createElement("div");
                slideCopy.className = "slide-copy";              
                slideCopy.innerHTML = `<p>${slides[i-1].title}</p><p>${slides[i-1].id}</p>`;

                slideImg.appendChild(img);
                slide.appendChild(slideImg);
                slide.appendChild(slideCopy);
                slider.appendChild(slide);

                const zPosition = initialZ + (i-1)*zStep;
                const xPosition = i%2 === 0 ? "30%" : "70%";
                const opacity = i === totalSlides ? 1: i === totalSlides - 1 ? 0 : 0;

                gsap.set(slide,{
                    top: "50%",
                    left: xPosition,
                    xPercent: -50,
                    yPercent: -50,
                    z: zPosition,
                    opacity: opacity,
                });
            }
        }


        window.addEventListener("load",function(){
            generateSlides();

            function getInitialTranslateZ(slide){
                return gsap.getProperty(slide,"z");
            }

            function mapRange(value, inMin, inMax,outMin, outMax){
                return (
                    ((value - inMin) * (outMax - outMin))/(inMax-inMin)+outMin
                );
            }
            
            ScrollTrigger.create({
                trigger: ".container",
                start: "top top",
                end: "bottom bottom",
                scrub: 1,
                onUpdate: (self) => {
                    uniforms.scrollOffset.value = self.progress;
                }
            });

            slides.forEach((slide,index) => {
                // const initialZ = getInitialTranslateZ()
                const initialZ = getInitialTranslateZ()


                ScrollTrigger.create({
                    trigger: ".container",
                    start: "top top",
                    end: "bottom bottom",
                    scrub: 1,

                    markers: true,  // Enable markers //debugging console.log
                    onEnter: () => console.log("Entered trigger area"),
                    onLeave: () => console.log("Left trigger area"),
                    onUpdate: (self) => console.log("Scroll progress:", self.progress),
                    onUpdate: (self) => {
                        const progress = self.progress;
                        const zIncrement = progress * 22500;
                        const currentZ = initialZ + zIncrement;

                        let opacity;

                        if (currentZ >= -2500){
                            opacity = mapRange(currentZ,-2500,0,0,1);
                        } else {
                            opacity = mapRange(currentZ,-5000,-2500,0,0);
                        }

                        slide.style.opacity = opacity;
                        slide.style.transform = `translateX(-50%) translateY(-50%) translateZ(${currentZ}px)`;
                }})});
        })
        
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
    <script src="https://unpkg.com/lenis@1.1.13/dist/lenis.min.js"></script>

    <script id="vertexShader" type="x-shader/x-vertex">
        void main(){
            gl_Position = vec4(position, 1.0); // Fixed this line
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform vec2 iResolution;
        uniform float iTime;
        uniform float scrollOffset;

        void mainImage(out vec4 o, vec2 I) {
            I -= o.zw = iResolution.xy / 2.0;
            float t = iTime * 5.0 + scrollOffset * 200.0; // Fixed this line
            float pattern = sin(atan(I.y, I.x) / 0.1) * sin(20.0 * (o.w /= length(I)) + t) - 1.0 + o.w;
            float monochrome = 1.0 * pattern * 0.5; // Fixed this line
            float invertedMonochrome = 1.0 - monochrome;
            o = vec4(invertedMonochrome, invertedMonochrome, invertedMonochrome, 1.0); // Fixed this line
        }

        void main() {
            mainImage(gl_FragColor, gl_FragCoord.xy);
        }
    </script>
</body>
</html>
<!-- //Credit to https://www.youtube.com/watch?v=MeHmt9kovSQ, but some of the codes are outdated -->